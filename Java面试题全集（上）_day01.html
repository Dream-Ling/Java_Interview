<html>
<head>
  <title>Java面试题全集（上）_day01</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/307474 (zh-CN, DDL); Windows/6.1.1 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="497"/>
<h1>Java面试题全集（上）_day01</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2018/5/15 22:27</i></td></tr>
<tr><td><b>作者：</b></td><td><i>凌小康</i></td></tr>
</table>
</div>
<br/>

<div>
<span><div><div><span style="font-weight: bold;">1、面向对象的特征有哪些方面？</span></div><div>答：面向对象的特征主要有以下几个方面：</div><div>- 抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。</div><div>- 继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段（如果不能理解请阅读阎宏博士的《Java与模式》或《设计模式精解》中关于桥梁模式的部分）。</div><div>- 封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别，明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是封装得足够好的，因为几个按键就搞定了所有的事情）。</div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">- 多态性：多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：当A系统访问B系统提供的服务时，B系统有多种提供服务的方式，但一切对A系统来说都是透明的（就像电动剃须刀是A系统，它的供电系统是B系统，B系统可以使用电池供电或者用交流电，甚至还有可能是太阳能，A系统只会通过B类对象调用供电的方法，但并不知道供电系统的底层实现是什么，究竟通过何种方式获得了动力）。方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：1). 方法重写（子类继承父类并重写父类中已有的或抽象的方法）；2). 对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。</span></div><div><span style="font-weight: bold;">2、访问修饰符public,private,protected,以及不写（默认）时的区别？</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">答：</span></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 130px;"></col><col style="width: 130px;"></col><col style="width: 130px;"></col><col style="width: 130px;"></col><col style="width: 130px;"></col></colgroup><tbody><tr><td style="width: 130px; padding: 8px; border: 1px solid rgb(204, 204, 204);"><div>修饰符</div></td><td style="width: 130px; padding: 8px; border: 1px solid rgb(204, 204, 204);"><div>当前类</div></td><td style="width: 130px; padding: 8px; border: 1px solid rgb(204, 204, 204);"><div>同 包</div></td><td style="width: 130px; padding: 8px; border: 1px solid rgb(204, 204, 204);"><div>子 类</div></td><td style="width: 130px; padding: 8px; border: 1px solid rgb(204, 204, 204);"><div>其他包</div></td></tr><tr><td style="width: 130px; padding: 8px; border: 1px solid rgb(204, 204, 204);"><div>public</div></td><td style="width: 130px; padding: 8px; border: 1px solid rgb(204, 204, 204);"><div>√</div></td><td style="width: 130px; padding: 8px; border: 1px solid rgb(204, 204, 204);"><div>√</div></td><td style="width: 130px; padding: 8px; border: 1px solid rgb(204, 204, 204);"><div>√</div></td><td style="width: 130px; padding: 8px; border: 1px solid rgb(204, 204, 204);"><div>√</div></td></tr><tr><td style="width: 130px; padding: 8px; border: 1px solid rgb(204, 204, 204);"><div>protected</div></td><td style="width: 130px; padding: 8px; border: 1px solid rgb(204, 204, 204);"><div>√</div></td><td style="width: 130px; padding: 8px; border: 1px solid rgb(204, 204, 204);"><div>√</div></td><td style="width: 130px; padding: 8px; border: 1px solid rgb(204, 204, 204);"><div>√</div></td><td style="width: 130px; padding: 8px; border: 1px solid rgb(204, 204, 204);"><div>×</div></td></tr><tr><td style="width: 130px; padding: 8px; border: 1px solid rgb(204, 204, 204);"><div>default</div></td><td style="width: 130px; padding: 8px; border: 1px solid rgb(204, 204, 204);"><div>√</div></td><td style="width: 130px; padding: 8px; border: 1px solid rgb(204, 204, 204);"><div>√</div></td><td style="width: 130px; padding: 8px; border: 1px solid rgb(204, 204, 204);"><div>×</div></td><td style="width: 130px; padding: 8px; border: 1px solid rgb(204, 204, 204);"><div>×</div></td></tr><tr><td style="width: 130px; padding: 8px; border: 1px solid rgb(204, 204, 204);"><div>private</div></td><td style="width: 130px; padding: 8px; border: 1px solid rgb(204, 204, 204);"><div>√</div></td><td style="width: 130px; padding: 8px; border: 1px solid rgb(204, 204, 204);"><div>×</div></td><td style="width: 130px; padding: 8px; border: 1px solid rgb(204, 204, 204);"><div>×</div></td><td style="width: 130px; padding: 8px; border: 1px solid rgb(204, 204, 204);"><div>×</div></td></tr></tbody></table><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">类的成员不写访问修饰时默认为default。默认对于同一个包中的其他类相当于公开（public），对于不是同一个包中的其他类相当于私有（private）。受保护（protected）对子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。Java中，外部类的修饰符只能是public或默认，类的成员（包括内部类）的修饰符可以是以上四种。</span></div><div><span style="font-weight: bold;">3、String 是最基本的数据类型吗？</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">答：不是。Java中的基本数据类型只有8个：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type）和枚举类型（enumeration type），剩下的都是引用类型（reference type）。</span></div><div><span style="font-weight: bold;">4、float f=3.4;是否正确？</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">答:不正确。3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f =(float)3.4; 或者写成float f =3.4F;。</span></div><div><span style="font-weight: bold;">5、short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗？</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">答：对于short s1 = 1; s1 = s1 + 1;由于1是int类型，因此s1+1运算结果也是int 型，需要强制转换类型才能赋值给short型。而short s1 = 1; s1 += 1;可以正确编译，因为s1+= 1;相当于s1 = (short)(s1 + 1);其中有隐含的强制类型转换。</span></div><div><span style="font-weight: bold;">6、Java有没有goto？</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">答：goto 是Java中的保留字，在目前版本的Java中没有使用。（根据James Gosling（Java之父）编写的《The Java Programming Language》一书的附录中给出了一个Java关键字列表，其中有goto和const，但是这两个是目前无法使用的关键字，因此有些地方将其称之为保留字，其实保留字这个词应该有更广泛的意义，因为熟悉C语言的程序员都知道，在系统类库中使用过的有特殊意义的单词或单词的组合都被视为保留字）</span></div><div><span style="font-weight: bold;">7、int和Integer有什么区别？</span></div><div>答：Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型（wrapper class），int的包装类就是Integer，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。</div><div>Java 为每个原始类型提供了包装类型：</div><div>- 原始类型: boolean，char，byte，short，int，long，float，double</div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">- 包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</span></div><table border="0"><colgroup><col></col><col></col></colgroup><tbody><tr><td><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div></td><td><div>class AutoUnboxingTest {</div><div> </div><div>    public static void main(String[] args) {</div><div>        Integer a = new Integer(3);</div><div>        Integer b = 3;                  // 将3自动装箱成Integer类型</div><div>        int c = 3;</div><div>        System.out.println(a == b);     // false 两个引用没有引用同一对象</div><div>        System.out.println(a == c);     // true a自动拆箱成int类型再和c比较</div><div>    }</div><div>}</div></td></tr></tbody></table><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">最近还遇到一个面试题，也是和自动装箱和拆箱有点关系的，代码如下所示：</span></div><table border="0"><colgroup><col></col><col></col></colgroup><tbody><tr><td><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div></td><td><div>public class Test03 {</div><div> </div><div>    public static void main(String[] args) {</div><div>        Integer f1 = 100, f2 = 100, f3 = 150, f4 = 150;</div><div> </div><div>        System.out.println(f1 == f2);</div><div>        System.out.println(f3 == f4);</div><div>    }</div><div>}</div></td></tr></tbody></table><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">如果不明就里很容易认为两个输出要么都是true要么都是false。首先需要注意的是f1、f2、f3、f4四个变量都是Integer对象引用，所以下面的==运算比较的不是值而是引用。装箱的本质是什么呢？当我们给一个Integer对象赋一个int值的时候，会调用Integer类的静态方法valueOf，如果看看valueOf的源代码就知道发生了什么。</span></div><table border="0"><colgroup><col></col><col></col></colgroup><tbody><tr><td><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div></td><td><div>public static Integer valueOf(int i) {</div><div>    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</div><div>        return IntegerCache.cache[i + (-IntegerCache.low)];</div><div>    return new Integer(i);</div><div>}</div></td></tr></tbody></table><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">IntegerCache是Integer的内部类，其代码如下所示：</span></div><table border="0"><colgroup><col></col><col></col></colgroup><tbody><tr><td><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div><div>13</div><div>14</div><div>15</div><div>16</div><div>17</div><div>18</div><div>19</div><div>20</div><div>21</div><div>22</div><div>23</div><div>24</div><div>25</div><div>26</div><div>27</div><div>28</div><div>29</div><div>30</div><div>31</div><div>32</div><div>33</div><div>34</div><div>35</div><div>36</div><div>37</div><div>38</div><div>39</div><div>40</div><div>41</div><div>42</div><div>43</div><div>44</div></td><td><div>/**</div><div>     * Cache to support the object identity semantics of autoboxing for values between</div><div>     * -128 and 127 (inclusive) as required by JLS.</div><div>     *</div><div>     * The cache is initialized on first usage.  The size of the cache</div><div>     * may be controlled by the {@code -XX:AutoBoxCacheMax=&lt;size&gt;} option.</div><div>     * During VM initialization, java.lang.Integer.IntegerCache.high property</div><div>     * may be set and saved in the private system properties in the</div><div>     * sun.misc.VM class.</div><div>     */</div><div> </div><div>    private static class IntegerCache {</div><div>        static final int low = -128;</div><div>        static final int high;</div><div>        static final Integer cache[];</div><div> </div><div>        static {</div><div>            // high value may be configured by property</div><div>            int h = 127;</div><div>            String integerCacheHighPropValue =</div><div>                sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);</div><div>            if (integerCacheHighPropValue != null) {</div><div>                try {</div><div>                    int i = parseInt(integerCacheHighPropValue);</div><div>                    i = Math.max(i, 127);</div><div>                    // Maximum array size is Integer.MAX_VALUE</div><div>                    h = Math.min(i, Integer.MAX_VALUE - (-low) -1);</div><div>                } catch( NumberFormatException nfe) {</div><div>                    // If the property cannot be parsed into an int, ignore it.</div><div>                }</div><div>            }</div><div>            high = h;</div><div> </div><div>            cache = new Integer[(high - low) + 1];</div><div>            int j = low;</div><div>            for(int k = 0; k &lt; cache.length; k++)</div><div>                cache[k] = new Integer(j++);</div><div> </div><div>            // range [-128, 127] must be interned (JLS7 5.1.7)</div><div>            assert IntegerCache.high &gt;= 127;</div><div>        }</div><div> </div><div>        private IntegerCache() {}</div><div>    }</div></td></tr></tbody></table><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">简单的说，如果整型字面量的值在-128到127之间，那么不会new新的Integer对象，而是直接引用常量池中的Integer对象，所以上面的面试题中f1==f2的结果是true，而f3==f4的结果是false。</span></div><blockquote><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;-en-paragraph:true;">提醒：</span><span style="-en-paragraph:true;">越是貌似简单的面试题其中的玄机就越多，需要面试者有相当深厚的功力。</span></div></blockquote><div><span style="font-weight: bold;">8、&amp;和&amp;&amp;的区别？</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">答：&amp;运算符有两种用法：(1)按位与；(2)逻辑与。&amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true。&amp;&amp;之所以称为短路运算是因为，如果&amp;&amp;左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用&amp;&amp;而不是&amp;，例如在验证用户登录时判定用户名不是null而且不是空字符串，应当写为：username != null &amp;&amp;!username.equals(“”)，二者的顺序不能交换，更不能用&amp;运算符，因为第一个条件如果不成立，根本不能进行字符串的equals比较，否则会产生NullPointerException异常。注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。</span></div><blockquote><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;-en-paragraph:true;">补充：</span><span style="-en-paragraph:true;">如果你熟悉JavaScript，那你可能更能感受到短路运算的强大，想成为JavaScript的高手就先从玩转短路运算开始吧。</span></div></blockquote><div><span style="font-weight: bold;">9、解释内存中的栈(stack)、堆(heap)和静态区(static area)的用法。</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">答：通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用内存中的栈空间；而通过new关键字和构造器创建的对象放在堆空间；程序中的字面量（literal）如直接书写的100、”hello”和常量都是放在静态区中。栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间，理论上整个内存没有被其他进程使用的空间甚至硬盘上的虚拟内存都可以被当成堆空间来使用。</span></div><table border="0"><colgroup><col></col><col></col></colgroup><tbody><tr><td><div>1</div></td><td><div>String str = new String(&quot;hello&quot;);</div></td></tr></tbody></table><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">上面的语句中变量str放在栈上，用new创建出来的字符串对象放在堆上，而”hello”这个字面量放在静态区。</span></div><blockquote><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;-en-paragraph:true;">补充：</span><span style="-en-paragraph:true;">较新版本的Java（从Java 6的某个更新开始）中使用了一项叫”逃逸分析”的技术，可以将一些局部对象放在栈上以提升对象的操作性能。</span></div></blockquote><div><span style="font-weight: bold;">10、Math.round(11.5) 等于多少？Math.round(-11.5)等于多少？</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">答：Math.round(11.5)的返回值是12，Math.round(-11.5)的返回值是-11。四舍五入的原理是在参数上加0.5然后进行下取整。</span></div><div><span style="font-weight: bold;">11、switch 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上？</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">答：在Java 5以前，switch(expr)中，expr只能是byte、short、char、int。从Java 5开始，Java中引入了枚举类型，expr也可以是enum类型，从Java 7开始，expr还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。</span></div><div><span style="font-weight: bold;">12、用最有效率的方法计算2乘以8？</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">答： 2 &lt;&lt; 3（左移3位相当于乘以2的3次方，右移3位相当于除以2的3次方）。</span></div><blockquote><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;-en-paragraph:true;">补充：</span><span style="-en-paragraph:true;">我们为编写的类重写hashCode方法时，可能会看到如下所示的代码，其实我们不太理解为什么要使用这样的乘法运算来产生哈希码（散列码），而且为什么这个数是个素数，为什么通常选择31这个数？前两个问题的答案你可以自己百度一下，选择31是因为可以用移位和减法运算来代替乘法，从而得到更好的性能。说到这里你可能已经想到了：31 * num 等价于(num &lt;&lt; 5) – num，左移5位相当于乘以2的5次方再减去自身就相当于乘以31，现在的VM都能自动完成这个优化。</span></div></blockquote><table border="0"><colgroup><col></col><col></col></colgroup><tbody><tr><td><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div><div>13</div><div>14</div><div>15</div><div>16</div><div>17</div><div>18</div><div>19</div><div>20</div><div>21</div><div>22</div><div>23</div><div>24</div><div>25</div><div>26</div><div>27</div><div>28</div><div>29</div><div>30</div><div>31</div><div>32</div><div>33</div><div>34</div><div>35</div><div>36</div><div>37</div><div>38</div><div>39</div><div>40</div><div>41</div></td><td><div>public class PhoneNumber {</div><div>    private int areaCode;</div><div>    private String prefix;</div><div>    private String lineNumber;</div><div> </div><div>    @Override</div><div>    public int hashCode() {</div><div>        final int prime = 31;</div><div>        int result = 1;</div><div>        result = prime * result + areaCode;</div><div>        result = prime * result</div><div>                + ((lineNumber == null) ? 0 : lineNumber.hashCode());</div><div>        result = prime * result + ((prefix == null) ? 0 : prefix.hashCode());</div><div>        return result;</div><div>    }</div><div> </div><div>    @Override</div><div>    public boolean equals(Object obj) {</div><div>        if (this == obj)</div><div>            return true;</div><div>        if (obj == null)</div><div>            return false;</div><div>        if (getClass() != obj.getClass())</div><div>            return false;</div><div>        PhoneNumber other = (PhoneNumber) obj;</div><div>        if (areaCode != other.areaCode)</div><div>            return false;</div><div>        if (lineNumber == null) {</div><div>            if (other.lineNumber != null)</div><div>                return false;</div><div>        } else if (!lineNumber.equals(other.lineNumber))</div><div>            return false;</div><div>        if (prefix == null) {</div><div>            if (other.prefix != null)</div><div>                return false;</div><div>        } else if (!prefix.equals(other.prefix))</div><div>            return false;</div><div>        return true;</div><div>    }</div><div> </div><div>}</div></td></tr></tbody></table><div><span style="font-weight: bold;">13、数组有没有length()方法？String有没有length()方法？</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">答：数组没有length()方法，有length 的属性。String 有length()方法。JavaScript中，获得字符串的长度是通过length属性得到的，这一点容易和Java混淆。</span></div><div><span style="font-weight: bold;">14、在Java中，如何跳出当前的多重嵌套循环？</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">答：在最外层循环前加一个标记如A，然后用break A;可以跳出多重循环。（Java中支持带标签的break和continue语句，作用有点类似于C和C++中的goto语句，但是就像要避免使用goto一样，应该避免使用带标签的break和continue，因为它不会让你的程序变得更优雅，很多时候甚至有相反的作用，所以这种语法其实不知道更好）</span></div><div><span style="font-weight: bold;">15、构造器（constructor）是否可被重写（override）？</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">答：构造器不能被继承，因此不能被重写，但可以被重载。</span></div><div><span style="font-weight: bold;">16、两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">答：不对，如果两个对象x和y满足x.equals(y) == true，它们的哈希码（hash code）应当相同。Java对于eqauls方法和hashCode方法是这样规定的：(1)如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同；(2)如果两个对象的hashCode相同，它们并不一定相同。当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在Set集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。</span></div><blockquote><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;-en-paragraph:true;">补充：</span><span style="-en-paragraph:true;">关于equals和hashCode方法，很多Java程序都知道，但很多人也就是仅仅知道而已，在Joshua Bloch的大作《</span><a href="http://www.amazon.com/gp/product/B000WJOUPA/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=B000WJOUPA&amp;linkCode=as2&amp;tag=job0ae-20" style="-en-paragraph:true;" title="Effective Java">Effective Java</a><span style="-en-paragraph:true;">》（很多软件公司，《Effective Java》、《</span><a href="http://www.amazon.cn/gp/product/B0011F7WU4/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B0011F7WU4&amp;linkCode=as2&amp;tag=importnew-23" style="-en-paragraph:true;" title="Java编程思想(第4版)">Java编程思想</a><span style="-en-paragraph:true;">》以及《</span><a href="http://www.amazon.cn/gp/product/B003BY6PLK/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;tag=importnew-23&amp;linkCode=as2&amp;camp=536&amp;creative=3200&amp;creativeASIN=B003BY6PLK" style="-en-paragraph:true;" title="重构">重构</a><span style="-en-paragraph:true;">：改善既有代码质量》是Java程序员必看书籍，如果你还没看过，那就赶紧去亚马逊买一本吧）中是这样介绍equals方法的：首先equals方法必须满足自反性（x.equals(x)必须返回true）、对称性（x.equals(y)返回true时，y.equals(x)也必须返回true）、传递性（x.equals(y)和y.equals(z)都返回true时，x.equals(z)也必须返回true）和一致性（当x和y引用的对象信息没有被修改时，多次调用x.equals(y)应该得到同样的返回值），而且对于任何非null值的引用x，x.equals(null)必须返回false。实现高质量的equals方法的诀窍包括：1. 使用==操作符检查”参数是否为这个对象的引用”；2. 使用instanceof操作符检查”参数是否为正确的类型”；3. 对于类中的关键属性，检查参数传入对象的属性是否与之相匹配；4. 编写完equals方法后，问自己它是否满足对称性、传递性、一致性；5. 重写equals时总是要重写hashCode；6. 不要将equals方法参数中的Object对象替换为其他的类型，在重写时不要忘掉@Override注解。</span></div></blockquote><div><span style="font-weight: bold;">17、是否可以继承String类？</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">答：String 类是final类，不可以被继承。</span></div><blockquote><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;-en-paragraph:true;">补充：</span><span style="-en-paragraph:true;">继承String本身就是一个错误的行为，对String类型最好的重用方式是关联关系（Has-A）和依赖关系（Use-A）而不是继承关系（Is-A）。</span></div></blockquote><div><span style="font-weight: bold;">18、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">答：是值传递。Java语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的。C++和C#中可以通过传引用或传输出参数来改变传入的参数的值。在C#中可以编写如下所示的代码，但是在Java中却做不到。</span></div><table border="0"><colgroup><col></col><col></col></colgroup><tbody><tr><td><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div><div>13</div><div>14</div><div>15</div><div>16</div><div>17</div><div>18</div><div>19</div></td><td><div>using System;</div><div> </div><div>namespace CS01 {</div><div> </div><div>    class Program {</div><div>        public static void swap(ref int x, ref int y) {</div><div>            int temp = x;</div><div>            x = y;</div><div>            y = temp;</div><div>        }</div><div> </div><div>        public static void Main (string[] args) {</div><div>            int a = 5, b = 10;</div><div>            swap (ref a, ref b);</div><div>            // a = 10, b = 5;</div><div>            Console.WriteLine (&quot;a = {0}, b = {1}&quot;, a, b);</div><div>        }</div><div>    }</div><div>}</div></td></tr></tbody></table><blockquote><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">说明：Java中没有传引用实在是非常的不方便，这一点在Java 8中仍然没有得到改进，正是如此在Java编写的代码中才会出现大量的Wrapper类（将需要通过方法调用修改的引用置于一个Wrapper类中，再将Wrapper对象传入方法），这样的做法只会让代码变得臃肿，尤其是让从C和C++转型为Java程序员的开发者无法容忍。</span></div></blockquote><div><span style="font-weight: bold;">19、String和StringBuilder、StringBuffer的区别？</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">答：Java平台提供了两种类型的字符串：String和StringBuffer/StringBuilder，它们可以储存和操作字符串。其中String是只读字符串，也就意味着String引用的字符串内容是不能被改变的。而StringBuffer/StringBuilder类表示的字符串对象可以直接进行修改。StringBuilder是Java 5中引入的，它和StringBuffer的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方面都没有被synchronized修饰，因此它的效率也比StringBuffer要高。</span></div><blockquote><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;-en-paragraph:true;">面试题1</span><span style="-en-paragraph:true;"> - 什么情况下用+运算符进行字符串连接比调用StringBuffer/StringBuilder对象的append方法连接字符串性能更好？</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;-en-paragraph:true;">面试题2</span><span style="-en-paragraph:true;"> - 请说出下面程序的输出。</span></div></blockquote><table border="0"><colgroup><col></col><col></col></colgroup><tbody><tr><td><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div></td><td><div>class StringEqualTest {</div><div> </div><div>    public static void main(String[] args) {</div><div>        String s1 = &quot;Programming&quot;;</div><div>        String s2 = new String(&quot;Programming&quot;);</div><div>        String s3 = &quot;Program&quot; + &quot;ming&quot;;</div><div>        System.out.println(s1 == s2);</div><div>        System.out.println(s1 == s3);</div><div>        System.out.println(s1 == s1.intern());</div><div>    }</div><div>}</div></td></tr></tbody></table><blockquote><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">补充：String对象的intern方法会得到字符串对象在常量池中对应的版本的引用（如果常量池中有一个字符串与String对象的equals结果是true），如果常量池中没有对应的字符串，则该字符串将被添加到常量池中，然后返回常量池中字符串的引用。</span></div></blockquote><div><span style="font-weight: bold;">20、重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">答：方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。</span></div><blockquote><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;-en-paragraph:true;">面试题：</span><span style="-en-paragraph:true;">华为的面试题中曾经问过这样一个问题 – “为什么不能根据返回类型来区分重载”，快说出你的答案吧！</span></div></blockquote><div><span style="font-weight: bold;">21、描述一下JVM加载class文件的原理机制？</span></div><div>答：JVM中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java中的类加载器是一个重要的Java运行时系统组件，它负责在运行时查找和装入类文件中的类。</div><div>由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接（验证、准备和解析）和初始化。类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。加载完成后，Class对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。最后JVM对类进行初始化，包括：1)如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；2)如果类中存在初始化语句，就依次执行这些初始化语句。</div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader的子类）。从Java 2（JDK 1.2）开始，类加载过程采取了父亲委托机制（PDM）。PDM更好的保证了Java平台的安全性，在该机制中，JVM自带的Bootstrap是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM不会向Java程序提供对Bootstrap的引用。下面是关于几个类加载器的说明：</span></div><blockquote><ul><li><div>Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）；</div></li><li><div>Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap；</div></li><li><div>System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。</div></li></ul></blockquote><div><span style="font-weight: bold;">22、char 型变量中能不能存贮一个中文汉字，为什么？</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">答：char类型可以存储一个中文汉字，因为Java中使用的编码是Unicode（不选择任何特定的编码，直接使用字符在字符集中的编号，这是统一的唯一方法），一个char类型占2个字节（16比特），所以放一个中文是没问题的。</span></div><blockquote><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;-en-paragraph:true;">补充：</span><span style="-en-paragraph:true;">使用Unicode意味着字符在JVM内部和外部有不同的表现形式，在JVM内部都是Unicode，当这个字符被从JVM内部转移到外部时（例如存入文件系统中），需要进行编码转换。所以Java中有字节流和字符流，以及在字符流和字节流之间进行转换的转换流，如InputStreamReader和OutputStreamReader，这两个类是字节流和字符流之间的适配器类，承担了编码转换的任务；对于C程序员来说，要完成这样的编码转换恐怕要依赖于union（联合体/共用体）共享内存的特征来实现了。</span></div></blockquote><div><span style="font-weight: bold;">23、抽象类（abstract class）和接口（interface）有什么异同？</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">答：抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用。一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类。接口比抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部都是抽象方法。抽象类中的成员可以是private、默认、protected、public的，而接口中的成员全都是public的。抽象类中可以定义成员变量，而接口中定义的成员变量实际上都是常量。有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法。</span></div><div><span style="font-weight: bold;">24、静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">答：Static Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化，其语法看起来挺诡异的，如下所示。</span></div><table border="0"><colgroup><col></col><col></col></colgroup><tbody><tr><td><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div><div>13</div><div>14</div><div>15</div><div>16</div><div>17</div><div>18</div><div>19</div><div>20</div><div>21</div><div>22</div><div>23</div><div>24</div><div>25</div><div>26</div><div>27</div><div>28</div><div>29</div><div>30</div><div>31</div><div>32</div><div>33</div><div>34</div><div>35</div><div>36</div><div>37</div><div>38</div><div>39</div><div>40</div><div>41</div><div>42</div><div>43</div><div>44</div><div>45</div><div>46</div><div>47</div><div>48</div><div>49</div><div>50</div><div>51</div><div>52</div><div>53</div><div>54</div><div>55</div><div>56</div><div>57</div><div>58</div><div>59</div><div>60</div><div>61</div><div>62</div><div>63</div><div>64</div><div>65</div><div>66</div><div>67</div><div>68</div><div>69</div><div>70</div><div>71</div><div>72</div><div>73</div><div>74</div><div>75</div></td><td><div>/**</div><div> * 扑克类（一副扑克）</div><div> * @author 骆昊</div><div> *</div><div> */</div><div>public class Poker {</div><div>    private static String[] suites = {&quot;黑桃&quot;, &quot;红桃&quot;, &quot;草花&quot;, &quot;方块&quot;};</div><div>    private static int[] faces = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13};</div><div> </div><div>    private Card[] cards;</div><div> </div><div>    /**</div><div>     * 构造器</div><div>     *</div><div>     */</div><div>    public Poker() {</div><div>        cards = new Card[52];</div><div>        for(int i = 0; i &lt; suites.length; i++) {</div><div>            for(int j = 0; j &lt; faces.length; j++) {</div><div>                cards[i * 13 + j] = new Card(suites[i], faces[j]);</div><div>            }</div><div>        }</div><div>    }</div><div> </div><div>    /**</div><div>     * 洗牌 （随机乱序）</div><div>     *</div><div>     */</div><div>    public void shuffle() {</div><div>        for(int i = 0, len = cards.length; i &lt; len; i++) {</div><div>            int index = (int) (Math.random() * len);</div><div>            Card temp = cards[index];</div><div>            cards[index] = cards[i];</div><div>            cards[i] = temp;</div><div>        }</div><div>    }</div><div> </div><div>    /**</div><div>     * 发牌</div><div>     * @param index 发牌的位置</div><div>     *</div><div>     */</div><div>    public Card deal(int index) {</div><div>        return cards[index];</div><div>    }</div><div> </div><div>    /**</div><div>     * 卡片类（一张扑克）</div><div>     * [内部类]</div><div>     * @author 骆昊</div><div>     *</div><div>     */</div><div>    public class Card {</div><div>        private String suite;   // 花色</div><div>        private int face;       // 点数</div><div> </div><div>        public Card(String suite, int face) {</div><div>            this.suite = suite;</div><div>            this.face = face;</div><div>        }</div><div> </div><div>        @Override</div><div>        public String toString() {</div><div>            String faceStr = &quot;&quot;;</div><div>            switch(face) {</div><div>            case 1: faceStr = &quot;A&quot;; break;</div><div>            case 11: faceStr = &quot;J&quot;; break;</div><div>            case 12: faceStr = &quot;Q&quot;; break;</div><div>            case 13: faceStr = &quot;K&quot;; break;</div><div>            default: faceStr = String.valueOf(face);</div><div>            }</div><div>            return suite + faceStr;</div><div>        }</div><div>    }</div><div>}</div></td></tr></tbody></table><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">测试代码：</span></div><table border="0"><colgroup><col></col><col></col></colgroup><tbody><tr><td><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div><div>13</div><div>14</div></td><td><div>class PokerTest {</div><div> </div><div>    public static void main(String[] args) {</div><div>        Poker poker = new Poker();</div><div>        poker.shuffle();                // 洗牌</div><div>        Poker.Card c1 = poker.deal(0);  // 发第一张牌</div><div>        // 对于非静态内部类Card</div><div>        // 只有通过其外部类Poker对象才能创建Card对象</div><div>        Poker.Card c2 = poker.new Card(&quot;红心&quot;, 1);    // 自己创建一张牌</div><div> </div><div>        System.out.println(c1);     // 洗牌后的第一张</div><div>        System.out.println(c2);     // 打印: 红心A</div><div>    }</div><div>}</div></td></tr></tbody></table><blockquote><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">面试题 – 下面的代码哪些地方会产生编译错误？</span></div></blockquote><table border="0"><colgroup><col></col><col></col></colgroup><tbody><tr><td><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div></td><td><div>class Outer {</div><div> </div><div>    class Inner {}</div><div> </div><div>    public static void foo() { new Inner(); }</div><div> </div><div>    public void bar() { new Inner(); }</div><div> </div><div>    public static void main(String[] args) {</div><div>        new Inner();</div><div>    }</div><div>}</div></td></tr></tbody></table><blockquote><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">注意：Java中非静态内部类对象的创建要依赖其外部类对象，上面的面试题中foo和main方法都是静态方法，静态方法中没有this，也就是说没有所谓的外部类对象，因此无法创建内部类对象，如果要在静态方法中创建内部类对象，可以这样做：</span></div></blockquote><table border="0"><colgroup><col></col><col></col></colgroup><tbody><tr><td><div>1</div></td><td><div>new Outer().new Inner();</div></td></tr></tbody></table><div><span style="font-weight: bold;">25、Java 中会存在内存泄漏吗，请简单描述。</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">答：理论上Java因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是Java被广泛使用于服务器端编程的一个重要原因）；然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被GC回收，因此也会导致内存泄露的发生。例如hibernate的Session（一级缓存）中的对象属于持久态，垃圾回收器是不会回收这些对象的，然而这些对象中可能存在无用的垃圾对象，如果不及时关闭（close）或清空（flush）一级缓存就可能导致内存泄露。下面例子中的代码也会导致内存泄露。</span></div><table border="0"><colgroup><col></col><col></col></colgroup><tbody><tr><td><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div><div>10</div><div>11</div><div>12</div><div>13</div><div>14</div><div>15</div><div>16</div><div>17</div><div>18</div><div>19</div><div>20</div><div>21</div><div>22</div><div>23</div><div>24</div><div>25</div><div>26</div><div>27</div><div>28</div><div>29</div><div>30</div></td><td><div>import java.util.Arrays;</div><div>import java.util.EmptyStackException;</div><div> </div><div>public class MyStack&lt;T&gt; {</div><div>    private T[] elements;</div><div>    private int size = 0;</div><div> </div><div>    private static final int INIT_CAPACITY = 16;</div><div> </div><div>    public MyStack() {</div><div>        elements = (T[]) new Object[INIT_CAPACITY];</div><div>    }</div><div> </div><div>    public void push(T elem) {</div><div>        ensureCapacity();</div><div>        elements[size++] = elem;</div><div>    }</div><div> </div><div>    public T pop() {</div><div>        if(size == 0)</div><div>            throw new EmptyStackException();</div><div>        return elements[--size];</div><div>    }</div><div> </div><div>    private void ensureCapacity() {</div><div>        if(elements.length == size) {</div><div>            elements = Arrays.copyOf(elements, 2 * size + 1);</div><div>        }</div><div>    }</div><div>}</div></td></tr></tbody></table><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">上面的代码实现了一个栈（先进后出（FILO））结构，乍看之下似乎没有什么明显的问题，它甚至可以通过你编写的各种单元测试。然而其中的pop方法却存在内存泄露的问题，当我们用pop方法弹出栈中的对象时，该对象不会被当作垃圾回收，即使使用栈的程序不再引用这些对象，因为栈内部维护着对这些对象的过期引用（obsolete reference）。在支持垃圾回收的语言中，内存泄露是很隐蔽的，这种内存泄露其实就是无意识的对象保持。如果一个对象引用被无意识的保留起来了，那么垃圾回收器不会处理这个对象，也不会处理该对象引用的其他对象，即使这样的对象只有少数几个，也可能会导致很多的对象被排除在垃圾回收之外，从而对性能造成重大影响，极端情况下会引发Disk Paging（物理内存与硬盘的虚拟内存交换数据），甚至造成OutOfMemoryError。</span></div><div><span style="font-weight: bold;">26、抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰？</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">答：都不能。抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。本地方法是由本地代码（如C代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。synchronized和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。</span></div><div><span style="font-weight: bold;">27、阐述静态变量和实例变量的区别。</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">答：静态变量是被static修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝；实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。</span></div><blockquote><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;-en-paragraph:true;">补充：</span><span style="-en-paragraph:true;">在Java开发中，上下文类和工具类中通常会有大量的静态成员。</span></div></blockquote><div><span style="font-weight: bold;">28、是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？</span></div><div><span style="-en-paragraph:true;">答：不可以，静态方法只能访问静态成员，因为非静态方法的调用要先创建对象，在调用静态方法时可能对象并没有被初始化。</span></div></div></span>
</div></body></html> 