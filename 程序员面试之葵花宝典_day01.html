<html>
<head>
  <title>程序员面试之葵花宝典_day01</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/307474 (zh-CN, DDL); Windows/6.1.1 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="502"/>
<h1>程序员面试之葵花宝典_day01</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2018/5/15 14:37</i></td></tr>
<tr><td><b>作者：</b></td><td><i>凌小康</i></td></tr>
</table>
</div>
<br/>

<div>
<span><div><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">1</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">、面向对象的特征有哪些方面</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">1.</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">抽象：抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一是过程抽象，二是数据抽象。</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">2.</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">继承：继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">3.</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">封装：封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">4.</span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">多态性：多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">2</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">、</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">String</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">是最基本的数据类型吗</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">?</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">基本数据类型包括</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">byte</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">、</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">int</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">、</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">char</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">、</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">long</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">、</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">float</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">、</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">double</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">、</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">boolean</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">和</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">short</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">。</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">java.lang.String</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">类是</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">final</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">类型的，因此不可以继承这个类、不能修改这个类。为了提高效率节省空间，我们应该用</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">StringBuffer</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">类</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">3</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">、</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">int</span> <span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">和</span> <span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Integer</span> <span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">有什么区别</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Java</span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">提供两种不同的类型：引用类型和原始类型（或内置类型）。</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Int</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">是</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">java</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">的原始数据类型，</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Integer</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">是</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">java</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">为</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">int</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">提供的封装类。</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Java</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">为每个原始类型提供了封装类。</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">原始类型封装类</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">booleanBoolean</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体; mso-spacerun: yes;-en-paragraph:true;"> </span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">charCharacter</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体; mso-spacerun: yes;-en-paragraph:true;"> </span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">byteByte</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体; mso-spacerun: yes;-en-paragraph:true;"> </span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">shortShort</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体; mso-spacerun: yes;-en-paragraph:true;"> </span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">intInteger</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体; mso-spacerun: yes;-en-paragraph:true;"> </span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">longLong</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体; mso-spacerun: yes;-en-paragraph:true;"> </span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">floatFloat</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体; mso-spacerun: yes;-en-paragraph:true;"> </span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">doubleDouble</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">引用类型和原始类型的行为完全不同，并且它们具有不同的语义。引用类型和原始类型具有不同的特征和用法，它们包括：大小和速度问题，这种类型以哪种类型的数据结构存储，当引用类型和原始类型用作某个类的实例数据时所指定的缺省值。对象引用实例变量的缺省值为</span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">null</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">，而原始类型实例变量的缺省值与它们的类型有关。</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">4</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">、</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">String</span> <span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">和</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">StringBuffer</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">的区别</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">JAVA</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">平台提供了两个类：</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">String</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">和</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">StringBuffer</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">，它们可以储存和操作字符串，即包含多个字符的字符数据。这个</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">String</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">类提供了数值不可改变的字符串。而这个</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">StringBuffer</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">类提供的字符串进行修改。当你知道字符数据要改变的时候你就可以使用</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">StringBuffer</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">。典型地，你可以使用</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">StringBuffers</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">来动态构造字符数据。</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">5</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">、运行时异常与一般异常有何异同？</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误。</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">java</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">编译器要求方法必须声明抛出可能发生的非运行时异常，但是并不要求必须声明抛出未被捕获的运行时异常。</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">6</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">、说出</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Servlet</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">的生命周期，并说出</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Servlet</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">和</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">CGI</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">的区别。</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Servlet</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">被服务器实例化后，容器运行其</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">init</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">方法，请求到达时运行其</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">service</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">方法，</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">service</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">方法自动派遣运行与请求对应的</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">doXXX</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">方法（</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">doGet</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">，</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">doPost</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">）等，当服务器决定将实例销毁的时候调用其</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">destroy</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">方法。</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">与</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">cgi</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">的区别在于</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">servlet</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">处于服务器进程中，它通过多线程方式运行其</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">service</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">方法，一个实例可以服务于多个请求，并且其实例一般不会销毁，而</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">CGI</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">servlet</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">。</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">7</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">、说出</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">ArrayList,Vector, LinkedList</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">的存储性能和特性</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">ArrayList</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">和</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Vector</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Vector</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">由于使用了</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">synchronized</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">方法（线程安全），通常性能上较</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">ArrayList</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">差，而</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">LinkedList</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">8</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">、</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">EJB</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">是基于哪些技术实现的？并说出</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">SessionBean</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">和</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">EntityBean</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">的区别，</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">StatefulBean</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">和</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">StatelessBean</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">的区别。</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体; mso-spacerun: yes;-en-paragraph:true;">   </span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">EJB</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">包括</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Session Bean</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">、</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Entity Bean</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">、</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Message Driven Bean</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">，基于</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">JNDI</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">、</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">RMI</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">、</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">JAT</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">等技术实现。</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">SessionBean</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">在</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">J2EE</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">应用程序中被用来完成一些服务器端的业务操作，例如访问数据库、调用其他</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">EJB</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">组件。</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">EntityBean</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">被用来代表应用系统中用到的数据。</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">对于客户机，</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">SessionBean</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">是一种非持久性对象，它实现某些在服务器上运行的业务逻辑。</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">对于客户机，</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">EntityBean</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">是一种持久性对象，它代表一个存储在持久性存储器中的实体的对象视图，或是一个由现有企业应用程序实现的实体。</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Session Bean</span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">还可以再细分为</span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Stateful Session Bean</span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">与</span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Stateless Session Bean</span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">，这两种的</span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Session Bean</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">都可以将系统逻辑放在</span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">method</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">之中执行，不同的是</span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Stateful Session Bean</span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">可以记录呼叫者的状态，因此通常来说，一个使用者会有一个相对应的</span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Stateful Session Bean</span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">的实体。</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Stateless Session Bean</span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">虽然也是逻辑组件，但是他却不负责记录使用者状态，也就是说当使用者呼叫</span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Stateless Session Bean</span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">的时候，</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">EJB Container</span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">并不会找寻特定的</span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Stateless Session Bean</span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">的实体来执行这个</span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">method</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">。换言之，很可能数个使用者在执行某个</span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Stateless Session Bean</span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">的</span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">methods</span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">时，会是同一个</span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Bean</span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">的</span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Instance</span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">在执行。从内存方面来看，</span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Stateful Session Bean</span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">与</span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Stateless Session Bean</span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">比较，</span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Stateful Session Bean</span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">会消耗</span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">J2EE Server</span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">较多的内存，然而</span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Stateful Session Bean</span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">的优势却在于他可以维持使用者的状态。</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">9</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">、</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Collection</span> <span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">和</span> <span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Collections</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">的区别。</span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Collection</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">是集合类的上级接口，继承与他的接口主要有</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Set</span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">和</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">List.</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Collections</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">10</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">、</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">&amp;</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">和</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">&amp;&amp;</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">的区别。</span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">&amp;</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">是位运算符，表示按位与运算，</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">&amp;&amp;</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">是逻辑运算符，表示逻辑与（</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">and</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">）。</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">11</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">、</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">HashMap</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">和</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Hashtable</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">的区别。</span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体; mso-spacerun: yes;-en-paragraph:true;"> </span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">HashMap</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">是</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Hashtable</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">的轻量级实现（非线程安全的实现），他们都完成了</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Map</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">接口，主要区别在于</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">HashMap</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">允许空（</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">null</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">）键值（</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">key</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">）</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">,</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">由于非线程安全，效率上可能高于</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Hashtable</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">。</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">HashMap</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">允许将</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">null</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">作为一个</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">entry</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">的</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">key</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">或者</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">value</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">，而</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Hashtable</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">不允许。</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">HashMap</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">把</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Hashtable</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">的</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">contains</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">方法去掉了，改成</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">containsvalue</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">和</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">containsKey</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">。因为</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">contains</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">方法容易让人引起误解。</span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Hashtable</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">继承自</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Dictionary</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">类，而</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">HashMap</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">是</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Java1.2</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">引进的</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Map interface</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">的一个实现。</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">最大的不同是，</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Hashtable</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">的方法是</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Synchronize</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">的，而</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">HashMap</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">不是，在多个线程访问</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Hashtable</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">时，不需要自己为它的方法实现同步，而</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">HashMap</span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">就必须为之提供外同步。</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Hashtable</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">和</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">HashMap</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">采用的</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">hash/rehash</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">算法都大概一样，所以性能不会有很大的差异。</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">12</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">、</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">final, finally, finalize</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">的区别。</span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">final</span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">finally</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">是异常处理语句结构的一部分，表示总是执行。</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">finalize</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">是</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Object</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">13</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">、</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">sleep()</span> <span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">和</span> <span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">wait()</span> <span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">有什么区别</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">?</span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">sleep</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">是线程类（</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Thread</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">）的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">sleep</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">不会释放对象锁。</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">wait</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">是</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Object</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">类的方法，对此对象调用</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">wait</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">notify</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">方法（或</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">notifyAll</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">）后本线程才进入对象锁定池准备获得对象锁进入运行状态。</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">14</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">、</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Overload</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">和</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Override</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">的区别。</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Overloaded</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">的方法是否可以改变返回值的类型</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">?</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">方法的重写</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Overriding</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">和重载</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Overloading</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">是</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Java</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">多态性的不同表现。重写</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Overriding</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">是父类与子类之间多态性的一种表现，重载</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Overloading</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写</span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">(Overriding)</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被“屏蔽”了。如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">(Overloading)</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">。</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Overloaded</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">的方法是可以改变返回值的类型。</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">15</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">、</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">error</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">和</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">exception</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">有什么区别</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">?</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">error</span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的情况。</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">exception</span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况。</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">16</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">、同步和异步有何异同，在什么情况下分别使用他们？举例说明。</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">17</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">、</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">abstract class</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">和</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">interface</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">有什么区别</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">?</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">声明方法的存在而不去实现它的类被叫做抽象类（</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">abstract class</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">），它用于要创建一个体现某些基本行为的类，并为该类声明方法，但不能在该类中实现该类的情况。不能创建</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">abstract</span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例。不能有抽象构造函数或抽象静态方法。</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Abstract</span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">类的子类为它们父类中的所有抽象方法提供实现，否则它们也是抽象类为。取而代之，在子类中实现该方法。知道其行为的其它类可以在类中实现这些方法。接口（</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">interface</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">）是抽象类的变体。在接口中，所有方法都是抽象的。多继承性可通过实现这样的接口而获得。接口中的所有方法都是抽象的，没有一个有程序体。接口只可以定义</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">static final</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">成员变量。接口的实现与子类相似，除了该实现类不能从接口定义中继承行为。当类实现特殊接口时，它定义（即将程序体给予）所有这种接口的方法。然后，它可以在实现了该接口的类的任何对象上调用接口的方法。由于有抽象类，它允许使用接口名作为引用变量的类型。通常的动态联编将生效。引用可以转换到接口类型或从接口类型转换，</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">instanceof</span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">运算符可以用来决定某对象的类是否实现了接口。</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">18</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">、</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">heap</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">和</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">stack</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">有什么区别。</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">栈是一种线形集合，其添加和删除元素的操作应在同一段完成。栈按照后进先出的方式进行处理。堆是栈的一个组成元素</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">19</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">、</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">forward</span> <span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">和</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">redirect</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">的区别</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">forward</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">是服务器请求资源，服务器直接访问目标地址的</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">URL</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">，把那个</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">URL</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">的响应内容读取过来，然后把这些内容再发给浏览器，浏览器根本不知道服务器发送的内容是从哪儿来的，所以它的地址栏中还是原来的地址。</span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">redirect</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">就是服务端根据逻辑</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">,</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">发送一个状态码</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">,</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">告诉浏览器重新去请求那个地址，一般来说浏览器会用刚才请求的所有参数重新请求，所以</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">session,request</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">参数都可以获取。</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">20</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">、</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">EJB</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">与</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">JAVA BEAN</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">的区别？</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体; mso-spacerun: yes;-en-paragraph:true;">   </span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Java Bean</span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">是可复用的组件，对</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Java Bean</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">并没有严格的规范，理论上讲，任何一个</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Java</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">类都可以是一个</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Bean</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">。但通常情况下，由于</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Java Bean</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">是被容器所创建（如</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Tomcat</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">）的，所以</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Java Bean</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">应具有一个无参的构造器，另外，通常</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Java Bean</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">还要实现</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Serializable</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">接口用于实现</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Bean</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">的持久性。</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Java Bean</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">实际上相当于微软</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">COM</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">模型中的本地进程内</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">COM</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">组件，它是不能被跨进程访问的。</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Enterprise Java Bean</span> <span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">相当于</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">DCOM</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">，即分布式组件。它是基于</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Java</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">的远程方法调用（</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">RMI</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">）技术的，所以</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">EJB</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">可以被远程访问（跨进程、跨计算机）。但</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">EJB</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">必须被布署在诸如</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Webspere</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">、</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">WebLogic</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">这样的容器中，</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">EJB</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">客户从不直接访问真正的</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">EJB</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">组件，而是通过其容器访问。</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">EJB</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">容器是</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">EJB</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">组件的代理，</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">EJB</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">组件由容器所创建和管理。客户通过容器来访问真正的</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">EJB</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">组件。</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">21</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">、</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Static Nested Class</span> <span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">和</span> <span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">Inner Class</span><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体;-en-paragraph:true;">的不同。</span></div><div><span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体; mso-bidi-font-family: &quot;Times New Roman&quot;; mso-font-kerning: 1.0pt; mso-ansi-language: EN-US; mso-fareast-language: ZH-CN; mso-bidi-language: AR-SA; mso-spacerun: yes;">   </span> <span style="font-weight: bold; font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体; mso-bidi-font-family: &quot;Times New Roman&quot;; mso-font-kerning: 1.0pt; mso-ansi-language: EN-US; mso-fareast-language: ZH-CN; mso-bidi-language: AR-SA; mso-spacerun: yes;"> </span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体; mso-bidi-font-family: &quot;Times New Roman&quot;; mso-font-kerning: 1.0pt; mso-ansi-language: EN-US; mso-fareast-language: ZH-CN; mso-bidi-language: AR-SA;">Static Nested Class</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体; mso-bidi-font-family: &quot;Times New Roman&quot;; mso-font-kerning: 1.0pt; mso-ansi-language: EN-US; mso-fareast-language: ZH-CN; mso-bidi-language: AR-SA;">是被声明为静态（</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体; mso-bidi-font-family: &quot;Times New Roman&quot;; mso-font-kerning: 1.0pt; mso-ansi-language: EN-US; mso-fareast-language: ZH-CN; mso-bidi-language: AR-SA;">static</span><span style="font-size: 12.0pt; mso-bidi-font-size: 15.0pt; font-family: 宋体; mso-bidi-font-family: &quot;Times New Roman&quot;; mso-font-kerning: 1.0pt; mso-ansi-language: EN-US; mso-fareast-language: ZH-CN; mso-bidi-language: AR-SA;">）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化。</span></div></span>
</div></body></html> 